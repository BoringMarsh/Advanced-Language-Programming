/*2151294 信11 马威*/
#include<iostream>
#include<conio.h>
/* 函数实现部分，{ }内的东西可以任意调整，目前的return 0只是一个示例，可改变 */

/* 不允许定义任何形式的外部全局、静态全局、宏定义、只读变量 */

/***************************************************************************
  函数名称：tj_strlen
  功    能：求字符串str的长度
  输入参数：const char str[]待求长度的字符串（只读）
  返 回 值：int i：字符串的长度
  说    明：无
***************************************************************************/
int tj_strlen(const char str[])
{
    int i = 0;  /*定义所需变量，i为计数变量*/
    char c;     /*定义所需变量，c为取样字符变量*/

    /*每次让c取一次字符串中对应位置的字符，若不为尾零，i自增，取下一个字符；若为尾零，跳出循环*/
    while (1) {
        if (str[i] == '\0') {
            break;
        }

        else {
            c = str[i];
            i++;
        }
    }

    return i;
}

/***************************************************************************
  函数名称：tj_strcat
  功    能：将字符串s2追加到s1后面，含\0
  输入参数：char s1[]：待追加的字符数组
            const char s2[]：追加的字符数组（只读）
  返 回 值：0（按规定）
  说    明：本函数调用了tj_strlen()
***************************************************************************/
int tj_strcat(char s1[], const char s2[])
{
    int L1 = tj_strlen(s1);  /*定义所需变量，L1为s1的长度*/
    int L2 = tj_strlen(s2);  /*定义所需变量，L2为s2的长度*/
    int i;                   /*定义所需变量，i为计数变量*/

    /*从s1的尾零位置开始，依次追加s2的每个字符，包括\0*/
    for (i = 0; i <= L2; i++) {
        s1[L1 + i] = s2[i];
    }

    return 0;
}

/***************************************************************************
  函数名称：tj_strncat
  功    能：将字符串s2的前len个字符追加到s1后面，并添加\0
  输入参数：char s1[]：待追加的字符数组
            const char s2[]：追加的字符来自的字符数组（只读）
            const int len：追加字符个数（只读）
  返 回 值：0（按规定）
  说    明：1、本函数调用了tj_strlen()、tj_strcat()
            2、若len比s2的长度大，则追加整个s2即可（含\0），本函数处理方法是直接调用tj_strcat()
***************************************************************************/
int tj_strncat(char s1[], const char s2[], const int len)
{
    int L1 = tj_strlen(s1);  /*定义所需变量，L1为s1的长度*/
    int L2 = tj_strlen(s2);  /*定义所需变量，L2为s2的长度*/
    int i;                   /*定义所需变量，i为计数变量*/

    /*若len小于s2的长度，则从s1的尾零位置开始，依次追加s2的前len个字符，再添加\0*/
    if (len < L2) {
        for (i = 0; i < len; i++) {
            s1[L1 + i] = s2[i];
        }

        s1[L1 + len] = '\0';
    }

    /*若len大于或等于s2的长度，则直接调用tj_strcat()，追加整个s2*/
    else {
        tj_strcat(s1, s2);
    }

    return 0;
}

/***************************************************************************
  函数名称：tj_strcpy
  功    能：将字符串s2复制到s1中，覆盖s1中原内容，复制时包含\0
  输入参数：char s1[]：待覆盖的字符数组
            const char s2[]：覆盖的字符数组（只读）
  返 回 值：0（按规定）
  说    明：本函数调用了tj_strlen()
***************************************************************************/
int tj_strcpy(char s1[], const char s2[])
{
    int L = tj_strlen(s2);  /*定义所需变量，L为s2的长度*/
    int i;                  /*定义所需变量，i为计数变量*/

    /*将s1前L个字符替换为s2对应位置的字符，i可以取到L，将尾零也复制过来*/
    for (i = 0; i <= L; i++) {
        s1[i] = s2[i];
    }

    return 0;
}

/***************************************************************************
  函数名称：tj_strncpy
  功    能：将字符串s2的前len个字符复制到s1中，复制时不含\0
  输入参数：char s1[]：待覆盖的字符数组
            const char s2[]：覆盖的字符来自的字符数组（只读）
            const int len：复制字符个数（只读）
  返 回 值：0（按规定）
  说    明：1、本函数调用了tj_strlen()
            2、若len比s2的长度大，复制s2长度个字符即可（不含\0）
***************************************************************************/
int tj_strncpy(char s1[], const char s2[], const int len)
{
    int L = tj_strlen(s2);  /*定义所需变量，L为s2的长度*/
    int i;                  /*定义所需变量，i为计数变量*/

    /*若len小于s2的长度，只复制前len个字符，不包括\0*/
    if (len < L) {
        for (i = 0; i < len; i++) {
            s1[i] = s2[i];
        }
    }

    /*若len大于或等于s2的长度，复制s2长度个字符，不包含\0*/
    else {
        for (i = 0; i < L; i++) {
            s1[i] = s2[i];
        }
    }

    return 0;
}

/***************************************************************************
  函数名称：tj_strcmp
  功    能：比较字符串s1和s2的大小，英文字母要区分大小写
  输入参数：const char s1[]：待比较的字符数组s1（只读）
            const char s2[]：待比较的字符数组s2（只读）
  返 回 值：int ret：最后一对比较的字符ASCII码差值
  说    明：无
***************************************************************************/
int tj_strcmp(const char s1[], const char s2[])
{
    int i = 0;    /*定义所需变量，i为计数变量*/
    int ret = 0;  /*定义所需变量，ret是最后一对比较的字符ASCII码差值*/

    /*逐个比较s1、s2对应位置的字符，若有不相等的字符，则求出ASCII差值赋给ret后跳出*/
    /*若直到两个字符串的尾零同时比较前还没比出大小，则两字符串相等，将0赋给ret后跳出*/
    while (1) {
        if (s1[i] != s2[i]) {
            ret = int(s1[i]) - int(s2[i]);
            break;
        }

        else if (s1[i] == '\0' && s2[i] == '\0') {
            ret = 0;
            break;
        }

        i++;
    }

    return ret;
}

/***************************************************************************
  函数名称：tj_strcasecmp
  功    能：比较字符串s1和s2的大小，英文字母不分大小写
  输入参数：const char s1[]：待比较的字符数组s1（只读）
            const char s2[]：待比较的字符数组s2（只读）
  返 回 值：int ret：最后一对比较的字符ASCII码差值
  说    明：1、若不相等处字符是不同的大小写字母，则统一转换为小写后比较
            2、若不相等处是大写字母和其它字符，则返回对应小写字母和其它字符的差值
***************************************************************************/
int tj_strcasecmp(const char s1[], const char s2[])
{
    int i = 0;    /*定义所需变量，i为计数变量*/
    int ret = 0;  /*定义所需变量，ret是最后一对比较的字符ASCII码差值（按要求处理过的）*/
    const char n = 'a' - 'A';  /*定义所需常量，n为每个小写字母与对应大写字母的ASCII差值*/

    while (1) {
        if (s1[i] != s2[i]) {

            /*若不相等处，s1[i]是大写字母，s2[i]是小写字母，则将s1[i]转换为小写后比较*/
            /*由于字符串只读，将s1[i]加上n后再比较，若仍不等，将按要求处理过的ASCII差值赋给ret后跳出*/
            if ((s1[i] >= 'A' && s1[i] <= 'Z') && (s2[i] >= 'a' && s2[i] <= 'z')) {
                if (s1[i] + n != s2[i]) {
                    ret = s1[i] + n - s2[i];
                    break;
                }
            }


            /*若不相等处，s2[i]是大写字母，s1[i]是小写字母，则将s2[i]转换为小写后比较*/
            /*由于字符串只读，将s2[i]加上n后再比较，若仍不等，将按要求处理过的ASCII差值赋给ret后跳出*/
            else if ((s1[i] >= 'a' && s1[i] <= 'z') && (s2[i] >= 'A' && s2[i] <= 'Z')) {
                if (s1[i] != s2[i] + n) {
                    ret = s1[i] - s2[i] - n;
                    break;
                }
            }

            /*若不相等处，s1[i]是大写字母，s2[i]是其他字符，则将s1[i]转换为小写*/
            /*由于字符串只读，将s1[i]加上n，再将按要求处理过的ASCII差值赋给ret后跳出*/
            else if ((s1[i] >= 'A' && s1[i] <= 'Z') && (s2[i] < 'A' || s2[i]>'Z') && (s2[i] < 'a' || s2[i]>'z')) {
                ret = s1[i] + n - s2[i];
                break;
            }

            /*若不相等处，s2[i]是大写字母，s1[i]是其他字符，则将s2[i]转换为小写*/
            /*由于字符串只读，将s2[i]加上n，再将按要求处理过的ASCII差值赋给ret后跳出*/
            else if ((s1[i] < 'A' || s1[i]>'Z') && (s1[i] < 'a' || s1[i]>'z') && (s2[i] >= 'A' && s2[i] <= 'Z')) {
                ret = s1[i] - s2[i] - n;
                break;
            }

            /*若都不符合上述特殊情况，直接将s1[i]、s2[i]的ASCII差值赋给ret后跳出*/
            else {
                ret = s1[i] - s2[i];
                break;
            }
        }

        /*若直到两个字符串的尾零同时比较前还没比出大小，则两字符串相等，将0赋给ret后跳出*/
        else if (s1[i] == '\0' && s2[i] == '\0') {
            ret = 0;
            break;
        }

        i++;
    }

    return ret;
}

/***************************************************************************
  函数名称：tj_strncmp
  功    能：比较字符串s1和s2的前len个字符的大小，英文字母要区分大小写
  输入参数：const char s1[]：待比较的字符数组s1（只读）
            const char s2[]：待比较的字符数组s2（只读）
            const int len：比较字符的个数（只读）
  返 回 值：int ret：最后一对比较的字符ASCII码差值
  说    明：1、本函数调用了tj_strlen()、tj_strcmp()
            2、若len大于s1/s2中长度短的串，则比较到短串的\0即结束
***************************************************************************/
int tj_strncmp(const char s1[], const char s2[], const int len)
{
    int L1 = tj_strlen(s1);      /*定义所需变量，L1为s1的长度*/
    int L2 = tj_strlen(s2);      /*定义所需变量，L2为s2的长度*/
    int min, ret = 0, i = 0;     /*定义所需变量，min为s1、s2长度的最小值，ret为最后一对比较的字符ASCII码差值，i为计数变量*/

    /*比较L1、L2，将最小值赋给min*/
    if (L1 < L2) {
        min = L1;
    }

    else {
        min = L2;
    }

    /*若len大于min，相当于直接整个比较s1和s2，调用函数tj_strcmp()*/
    if (len > min) {
        ret = tj_strcmp(s1, s2);
    }

    else {

        /*逐个比较s1、s2标定范围内对应位置的字符*/
        while (i < len) {

            /*若有不相等的字符，则求出ASCII差值赋给ret后跳出*/
            if (s1[i] != s2[i]) {
                ret = int(s1[i]) - int(s2[i]);
                break;
            }

            /*若直到两个字符串的尾零同时比较前还没比出大小，则两字符串相等，将0赋给ret后跳出*/
            else if (s1[i] == '\0' && s2[i] == '\0') {
                ret = 0;
                break;
            }

            /*若直到两个字符串标定范围内，最后一对字符同时比较时还没比出大小，则两字符串相等，将0赋给ret后跳出*/
            else if (s1[i] == s2[i] && i == len - 1) {
                ret = 0;
                break;
            }

            i++;
        }
    }

    return ret;
}

/***************************************************************************
  函数名称：tj_strcasencmp
  功    能：比较字符串s1和s2前len个字符的大小，英文字母不分大小写
  输入参数：const char s1[]：待比较的字符数组s1（只读）
            const char s2[]：待比较的字符数组s2（只读）
            const int len：比较字符的个数（只读）
  返 回 值：int ret：最后一对比较的字符ASCII码差值
  说    明：1、本函数调用了tj_strlen()、tj_strcasecmp()
            2、若len大于s1/s2中长度短的串，则比较到短串的\0即结束
***************************************************************************/
int tj_strcasencmp(const char s1[], const char s2[], const int len)
{
    int L1 = tj_strlen(s1);    /*定义所需变量，L1为s1的长度*/
    int L2 = tj_strlen(s2);    /*定义所需变量，L2为s2的长度*/
    int min, ret = 0, i = 0;   /*定义所需变量，min为s1、s2长度的最小值，ret为最后一对比较的字符ASCII码差值，i为计数变量*/
    const char n = 'a' - 'A';  /*定义所需常量，n为每个小写字母与对应大写字母的ASCII差值*/

    /*比较L1、L2，将最小值赋给min*/
    if (L1 < L2) {
        min = L1;
    }

    else {
        min = L2;
    }

    /*若len大于min，相当于直接整个比较s1和s2，调用函数tj_strcasecmp()*/
    if (len > min) {
        ret = tj_strcasecmp(s1, s2);
    }

    else {

        /*逐个比较s1、s2标定范围内对应位置的字符*/
        while (i < len) {
            if (s1[i] != s2[i]) {

                /*若不相等处，s1[i]是大写字母，s2[i]是小写字母，则将s1[i]转换为小写后比较*/
                /*由于字符串只读，将s1[i]加上n后再比较，若仍不等，将按要求处理过的ASCII差值赋给ret后跳出*/
                if ((s1[i] >= 'A' && s1[i] <= 'Z') && (s2[i] >= 'a' && s2[i] <= 'z')) {
                    if (s1[i] + n != s2[i]) {
                        ret = s1[i] + n - s2[i];
                        break;
                    }
                }


                /*若不相等处，s2[i]是大写字母，s1[i]是小写字母，则将s2[i]转换为小写后比较*/
                /*由于字符串只读，将s2[i]加上n后再比较，若仍不等，将按要求处理过的ASCII差值赋给ret后跳出*/
                else if ((s1[i] >= 'a' && s1[i] <= 'z') && (s2[i] >= 'A' && s2[i] <= 'Z')) {
                    if (s1[i] != s2[i] + n) {
                        ret = s1[i] - s2[i] - n;
                        break;
                    }
                }

                /*若不相等处，s1[i]是大写字母，s2[i]是其他字符，则将s1[i]转换为小写*/
                /*由于字符串只读，将s1[i]加上n，再将按要求处理过的ASCII差值赋给ret后跳出*/
                else if ((s1[i] >= 'A' && s1[i] <= 'Z') && (s2[i] < 'A' || s2[i]>'Z') && (s2[i] < 'a' || s2[i]>'z')) {
                    ret = s1[i] + n - s2[i];
                    break;
                }

                /*若不相等处，s2[i]是大写字母，s1[i]是其他字符，则将s2[i]转换为小写*/
                /*由于字符串只读，将s2[i]加上n，再将按要求处理过的ASCII差值赋给ret后跳出*/
                else if ((s1[i] < 'A' || s1[i]>'Z') && (s1[i] < 'a' || s1[i]>'z') && (s2[i] >= 'A' && s2[i] <= 'Z')) {
                    ret = s1[i] - s2[i] - n;
                    break;
                }

                /*若都不符合上述特殊情况，直接将s1[i]、s2[i]的ASCII差值赋给ret后跳出*/
                else {
                    ret = s1[i] - s2[i];
                    break;
                }
            }

            /*若直到两个字符串的尾零同时比较前还没比出大小，则两字符串相等，将0赋给ret后跳出*/
            else if (s1[i] == '\0' && s2[i] == '\0') {
                ret = 0;
                break;
            }

            /*若直到两个字符串标定范围内，最后一对字符同时比较时还没比出大小，则两字符串相等，将0赋给ret后跳出*/
            else if (s1[i] == s2[i] && i == len - 1) {
                ret = 0;
                break;
            }

            i++;
        }
    }

    return ret;
}

/***************************************************************************
  函数名称：tj_strupr
  功    能：将字符串str中所有小写字母均转为大写，其他字符不变，转换后放在原串中
  输入参数：char str[]：待大写处理的字符数组
  返 回 值：0（按规定）
  说    明：本函数调用了tj_strlen()
***************************************************************************/
int tj_strupr(char str[])
{
    int L = tj_strlen(str);   /*定义所需变量，L为str的长度*/
    int i;                    /*定义所需变量，i为计数变量*/
    const int n = 'a' - 'A';  /*定义所需常量，n为每个小写字母与对应大写字母的ASCII差值*/

    /*逐个检查str中的每个字符，若检查出小写字母，则减去n，换成大写字母*/
    for (i = 0; i < L; i++) {
        if (str[i] >= 'a' && str[i] <= 'z') {
            str[i] = str[i] - n;
        }
    }

    return 0;
}

/***************************************************************************
  函数名称：tj_strlwr
  功    能：将字符串str中所有大写字母均转为小写，其他字符不变，转换后放在原串中
  输入参数：char str[]：待小写处理的字符数组
  返 回 值：0（按规定）
  说    明：本函数调用了tj_strlen()
***************************************************************************/
int tj_strlwr(char str[])
{
    int L = tj_strlen(str);   /*定义所需变量，L为str的长度*/
    int i;                    /*定义所需变量，i为计数变量*/
    const int n = 'a' - 'A';  /*定义所需常量，n为每个小写字母与对应大写字母的ASCII差值*/

    /*逐个检查str中的每个字符，若检查出大写字母，则加上n，换成小写字母*/
    for (i = 0; i < L; i++) {
        if (str[i] >= 'A' && str[i] <= 'Z') {
            str[i] = str[i] + n;
        }
    }

    return 0;
}

/***************************************************************************
  函数名称：tj_strchr
  功    能：在字符串str中寻找字符ch第1次出现的位置，顺序是从左到右
  输入参数：const char str[]：待检查的字符数组
            char ch：目标字符
  返 回 值：ret：ch在str中第一次出现的位置（从左到右）
  说    明：1、本函数调用了tj_strlen()
            2、若未找到，则返回零
***************************************************************************/
int tj_strchr(const char str[], char ch)
{
    int L = tj_strlen(str);   /*定义所需变量，L为str的长度*/
    int i, ret = 0;           /*定义所需变量，i为计数变量，ret为ch在str中第一次出现的位置*/

    /*逐个检查str中的每个字符，若检查出ch，则将i+1赋给ret后跳出*/
    for (i = 0; i < L; i++) {
        if (str[i] == ch) {
            ret = i + 1;
            break;
        }
    }

    return ret;
}

/***************************************************************************
  函数名称：tj_strstr
  功    能：在字符串str中寻找字符串substr第1次出现的位置，顺序是从左到右
  输入参数：const char str[]：待检查的字符数组（只读）
            const char substr[]：待寻找的字符数组（只读）
  返 回 值：int ret：字符串str中字符串substr第1次出现的位置（从左到右）
  说    明：1、本函数调用了tj_strlen()
            2、若未找到，则返回零
***************************************************************************/
int tj_strstr(const char str[], const char substr[])
{
    int L1 = tj_strlen(str);     /*定义所需变量，L1为s1的长度*/
    int L2 = tj_strlen(substr);  /*定义所需变量，L2为s2的长度*/
    int i, j, ret = 0;           /*定义所需变量，i、j均为计数变量，ret为字符串str中字符串substr第1次出现的位置*/

    /*逐个检查str中的字符，若跟substr首字母相同，则进入下一步检查*/
    for (i = 0; i < L1; i++) {
        if (str[i] == substr[0]) {

            /*从两个字符串当前位置逐个检查对应字符*/
            for (j = 0; j < L2; j++) {

                /*若有不相等字符，直接跳出*/
                if (str[j + i] != substr[j]) {
                    break;
                }

                /*若直到substr中全部字符都已连续找到，则将首字母在str中的位置赋给ret后跳出*/
                else if (str[j + i] == substr[j] && j == L2 - 1) {
                    ret = i + 1;
                    break;
                }
            }
        }

        /*若ret为零，则表示还未找到substr，不需跳出循环*/
        if (ret) {
            break;
        }
    }

    return ret;
}

/***************************************************************************
  函数名称：tj_strrchr
  功    能：在字符串str中寻找字符ch第1次出现的位置，顺序是从右到左
  输入参数：const char str[]：待检查的字符数组
            char ch：目标字符
  返 回 值：ret：ch在str中第一次出现的位置（从右到左）
  说    明：1、本函数调用了tj_strlen()
            2、若未找到，则返回零
***************************************************************************/
int tj_strrchr(const char str[], const char ch)
{
    int L = tj_strlen(str);   /*定义所需变量，L为str的长度*/
    int i, ret = 0;           /*定义所需变量，i为计数变量，ret为ch在str中第一次出现的位置*/

    /*反向逐个检查str中的每个字符，若检查出ch，则将i+1赋给ret后跳出*/
    for (i = L - 1; i >= 0; i--) {
        if (str[i] == ch) {
            ret = i + 1;
            break;
        }
    }

    return ret;
}

/***************************************************************************
  函数名称：tj_strrstr
  功    能：在字符串str中寻找字符串substr第1次出现的位置，顺序是从右到左
  输入参数：const char str[]：待检查的字符数组（只读）
            const char substr[]：待寻找的字符数组（只读）
  返 回 值：int ret：字符串str中字符串substr第1次出现的位置（从左到右）
  说    明：1、本函数调用了tj_strlen()
            2、若未找到，则返回零
***************************************************************************/
int tj_strrstr(const char str[], const char substr[])
{
    int L1 = tj_strlen(str);     /*定义所需变量，L1为s1的长度*/
    int L2 = tj_strlen(substr);  /*定义所需变量，L2为s2的长度*/
    int i, j, ret = 0;           /*定义所需变量，i、j均为计数变量，ret为字符串str中字符串substr第1次出现的位置*/
    int n;                       /*定义所需变量，n为第二步检查时，两个字符串当前位置的差值*/

    /*反向逐个检查str中的字符，若跟substr首字母相同，则进入下一步检查*/
    for (i = L1; i >= 0; i--) {
        if (str[i] == substr[L2 - 1]) {
            n = i - L2 + 1;

            /*从两个字符串当前位置反向逐个检查对应字符*/
            for (j = L2 - 1; j >= 0; j--) {

                /*若有不相等字符，直接跳出*/
                if (str[n+j] != substr[j]) {
                    break;
                }

                /*若直到substr中全部字符都已连续找到，则将首字母在str中的位置（从左到右）赋给ret后跳出*/
                else if (str[n + j] == substr[j] && j == 0) {
                    ret = (i + 1) - (L2 - 1);
                    break;
                }
            }
        }

        /*若ret为零，则表示还未找到substr，不需跳出循环*/
        if (ret) {
            break;
        }
    }

    return ret;
}

/***************************************************************************
  函数名称：tj_strrev
  功    能：字符串反转，放回原串中
  输入参数：char str[]：待反转处理的字符数组
  返 回 值：0（按规定）
  说    明：本函数调用了tj_strlen()
***************************************************************************/
int tj_strrev(char str[])
{
    int L = tj_strlen(str);  /*定义所需变量，L为str的长度*/
    char t;                  /*定义所需变量，t为充当中间值的字符变量*/
    int i;                   /*定义所需变量，i为计数变量*/
    int mid = (L - 1) / 2;   /*定义所需变量，mid为中点标记*/

    /*若L为零，无需做任何处理*/
    if (L == 0) {}

    /*若L为奇数，从0到mid-1，对称的元素依靠中间变量依次交换*/
    else if (L % 2 == 1) {
        for (i = 0; i < mid; i++) {
            t = str[i];
            str[i] = str[L - 1 - i];
            str[L - 1 - i] = t;
        }
    }

    /*若L为偶数，从0到mid，对称的元素依靠中间变量依次交换*/
    else if (L % 2 == 0) {
        for (i = 0; i <= mid; i++) {
            t = str[i];
            str[i] = str[L - 1 - i];
            str[L - 1 - i] = t;
        }
    }

    return 0;
}