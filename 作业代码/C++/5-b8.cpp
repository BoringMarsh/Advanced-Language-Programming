/*2151294 信11 马威*/
#include<iostream>
#include<cmath>
using namespace std;

/***************************************************************************
  函数名称：point_number
  功    能：通过正确性处理，输入并返回多边形的顶点数量
  输入参数：无
  返 回 值：int i：多边形的顶点数量
  说    明：1、此为第1个添加函数
			2、错误处理原则：若超范围，输出提示语+丢弃继续读；若输入状态错误，清空缓冲区+输出提示语
***************************************************************************/
int point_number()
{
	int i;
	
	while (1) {
		cout << "请输入多边形的顶点数量(4-7)" << endl;
		cin >> i;

		if (i >= 4 && i <= 7 && cin.good() == 1) {
			break;
		}

		else if ((i < 4 || i>7) && cin.good() == 1) {
			continue;
		}

		else if (cin.good() == 0) {
			cin.clear();
			cin.ignore(INT_MAX, '\n');
		}
	}

	return i;
}

int main()
{
	double x[7], y[7];  /*定义所需数组，x[7]是各点的横坐标，y[7]是各点的纵坐标*/
	int num, i, j;      /*定义所需变量，num是顶点个数，i、j都是计数变量*/

	/***************************************************************************
	  1、各个数组的初始化
	***************************************************************************/
	for (i = 0; i < 7; i++) {
		x[i] = 0;
		y[i] = 0;
	}

	/***************************************************************************
	  2、调用point_number，通过正确性处理输入顶点坐标个数
	***************************************************************************/
	num = point_number();

	/***************************************************************************
	  3、按顺时针/逆时针方向输入顶点坐标。处理错误原则：输入状态错误，清空缓冲区
	***************************************************************************/
	cout << "请按顺时针/逆时针方向输入" << num << "个顶点的x,y坐标：" << endl;
	for (i = 0; i < num; i++) {
		while (1) {
			cout << "请输入第" << i + 1 << "个顶点的坐标：" << endl;
			cin >> x[i] >> y[i];

			if (cin.good()) {
				break;
			}

			else {
				cin.clear();
				cin.ignore(INT_MAX, '\n');
			}
		}
	}

	/***************************************************************************
	  4、求每条边的斜率，若该边竖直，k[i]不变，使判断是否竖直的标志if_x[i](bool型)等于true
	***************************************************************************/

	double k[7];   /*定义所需数组，k[7]是表示每条边斜率的数组*/
	bool if_x[7];  /*定义所需数组，if_x[7]是表示每条边竖直情况的数组*/

	/*4.1、数组k[7]、if_x[7]的初始化*/
	for (i = 0; i < 7; i++) {
		k[i] = 0;
		if_x[i] = false;
	}

	for (i = 0; i < num; i++) {

		/*4.2、若求最后一条边的斜率，使用最后一点与第一个点的坐标计算*/
		if (i == num - 1) {
			if (x[num - 1] != x[0]) {
				k[i] = (y[num - 1] - y[0]) / (x[num - 1] - x[0]);
			}

			else {
				if_x[i] = true;
			}
		}

		/*4.3、若求的不是最后一条边的斜率，使用当前的点与下一个点的坐标计算*/
		else {
			if (x[i + 1] != x[i]) {
				k[i] = (y[i + 1] - y[i]) / (x[i + 1] - x[i]);
			}

			else {
				if_x[i] = true;
			}
		}
	}

	/***************************************************************************
	  5、通过每条边的斜率/竖直情况比较，检查是否存在三个及以上的点存在共线
	***************************************************************************/

	int limit1, limit2;  /*定义所需变量，limit1、limit2是每条边的两侧边的编号*/
	int if_in_line = 0;  /*定义所需变量，if_in_line是标志各点是否存在共线的标志*/

	for (i = 0; i < num; i++) {

		/*5.1、根据当前边的编号，确定相邻两条边的编号*/
		/*5.1.1、若为第一条边，与最后一条边和下一条边比较*/
		if (i == 0) {
			limit1 = num - 1;
			limit2 = i + 1;
		}

		/*5.1.2、若为中间的边，与上一条边和下一条边比较*/
		else if (i > 0 && i < num - 1) {
			limit1 = i - 1;
			limit2 = i + 1;
		}

		/*5.1.3、若为最后一条边，与上一条边和第一条边比较*/
		else if (i == num - 1) {
			limit1 = i - 1;
			limit2 = 0;
		}

		/*5.2、已确定上值和下值，比较当前边与两侧边的斜率/竖直情况*/
		/*5.2.1、若当前边竖直，只要两侧边存在一条边也为竖直，就可判定存在多个点共线，if_in_line自增*/
		if (if_x[i]) {
			if (if_x[limit1] == if_x[i] || if_x[i] == if_x[limit2]) {
				if_in_line++;
			}
		}

		/*5.2.2、若当前边不竖直，分两侧边的情况讨论*/
		else {

			/*5.2.2.1、若一侧边竖直，另一侧边不竖直，只要不竖直的侧边斜率和当前边相等，就可判定存在多个点共线，if_in_line自增*/
			if (if_x[limit1] == true && if_x[limit2] == false) {
				if (k[i] == k[limit2]) {
					if_in_line++;
				}
			}

			/*5.2.2.2、若另一侧边竖直，一侧边不竖直，只要不竖直的侧边斜率和当前边相等，就可判定存在多个点共线，if_in_line自增*/
			else if (if_x[limit1] == false && if_x[limit2] == true) {
				if (k[i] == k[limit1]) {
					if_in_line++;
				}
			}

			/*5.2.2.3、若两侧边都不竖直，只要两侧边存在一条边斜率与当前边相等，就可判定存在多个点共线，if_in_line自增*/
			else if (if_x[limit1] == false && if_x[limit2] == false) {
				if (k[i] == k[limit1] || k[i] == k[limit2]) {
					if_in_line++;
				}
			}
		}
	}

	/*5.3、根据if_in_line的值，判定是否存在多个点共线*/

	bool line;  /*定义所需变量，line是标志是否存在共线的变量*/

	/*由于一旦检查出共线，if_in_line就会自增，故可以根据if_in_line的值，判定是否存在多个点共线：若为零，则不存在共线；否则存在共线*/
	if (if_in_line == 0) {
		line = true;
	}

	else {
		line = false;
	}

	/***************************************************************************
	  6、每两个点确定一条直线时，检查所有其他的点是否都在该线同一侧
	***************************************************************************/
	
	int limit3, limit4;  /*定义所需变量，limit3、limit4是确定当前边两个点的编号*/
	double d[7];         /*定义所需数组，d[7]是其余点与线的差值*/
	int if_cp[7];        /*定义所需数组，if_cp[7]是表示每条边两侧点数量情况的数组*/

	/*6.1、数组if_cp[7]的初始化*/
	for (i = 0; i < 7; i++) {
		if_cp[i] = 0;
	}

	for (i = 0; i < num; i++) {

		/*6.2、根据当前边的编号，确定这条边两端点的编号*/
		/*若不为最后一条边，两端点为这一个点和下一个点*/
		if (i != num - 1) {
			limit3 = i;
			limit4 = i + 1;
		}

		/*若为最后一条边，两端点为这一个点和第一个点*/
		else {
			limit3 = i;
			limit4 = 0;
		}

		/*6.3、已确定两端点，比较其余各点与当前边的位置情况*/
		/*6.3.1、若当前边竖直，只需比较其余各点的横坐标与当前边的横坐标即可*/
		if (if_x[i] == true) {
			for (j = 0; j < num; j++) {
				if (j != limit3 && j != limit4) {  /*其余各点不能是两端点*/
					d[j] = x[j] - x[i];  /*计算差值*/
					if (d[j] > 1e-6) {
						if_cp[i] = if_cp[i] + 1;  /*在当前边的一侧，if_cp[i]自增*/
					}

					else if (d[j] < -1e-6) {
						if_cp[i] = if_cp[i] - 1;  /*在当前边的另一侧，if_cp[i]自减*/
					}
				}
			}
		}

		/*6.3.2、若当前边不竖直，将其余各点的横坐标代入当前边的解析式，再将得到的纵坐标与其余各点的纵坐标比较*/
		else {
			for (j = 0; j < num; j++) {
				if (j != limit3 && j != limit4) {  /*其余各点不能是两端点*/
					d[j] = y[j] - k[i] * (x[j] - x[i]) - y[i];  /*计算差值*/
					if (d[j] > 1e-6) {
						if_cp[i] = if_cp[i] + 1;  /*在当前边的一侧，if_cp[i]自增*/
					}

					else if (d[j] < -1e-6) {
						if_cp[i] = if_cp[i] - 1;  /*在当前边的另一侧，if_cp[i]自减*/
					}
				}
			}
		}
	}

	/*6.4、根据if_cp[i]的值，判断多边形是否为凸*/

	bool cp = true;  /*定义所需变量，cp为标志多边形是否为凸的变量，初始化为true*/

	/*检查每一项绝对值是否等于num-2，是则说明除两端点外的所有点都在当前边的同一侧，多边形为凸；否则不为凸*/
	for (i = 0; i < num; i++) {
		if (int(fabs(if_cp[i])) != num - 2) {  /*只要检查出有不在同一侧，cp为false，直接结束检查*/
			cp = false;
			break;
		}
	}

	/***************************************************************************
	  7、综合两个条件的判定结果，决定下一步行动
	***************************************************************************/

	/*7.1、若该多边形既无共线、又为凸多边形，则计算其面积*/
	if (cp == true && line == true) {
		double S[7];  /*定义所需数组，S[7]为表示多边形每一部分面积的数组*/

	    /*7.1.1、数组S[7]的初始化*/
		for (i = 0; i < 7; i++) {
			S[i] = 0;
		}

		/*7.1.2、运用前后点的二阶行列式，计算多边形每一部分的面积*/
		for (i = 0; i < num; i++) {
			if (i != num - 1) {  /*若当前点不是最后一点，则使用当前点和下一个点的坐标计算*/
				S[i] = x[i] * y[i + 1] - x[i + 1] * y[i];
			}

			else {  /*若当前点是最后一点，则使用当前点和第一个点的坐标计算*/
				S[i] = x[i] * y[0] - x[0] * y[i];
			}
		}

		double S_all = 0;  /*定义所需变量，S_all是多边形的总面积*/

		/*7.1.3、对S[i]各项求和，赋给S_all*/
		for (i = 0; i < num; i++) {
			S_all = S_all + S[i];
		}

		/*7.1.4、由于逆时针输入坐标时，S_all为负，所以取绝对值。再根据计算面积原理除以2，得到最终的结果并输出*/
		S_all = fabs(S_all / 2);
		cout << "凸" << num << "边形的面积=" << S_all << endl;
	}

	/*7.2、若该多边形存在共线，或为凹多边形，则输出提示语后结束*/
	else {
		cout << "不是凸" << num << "边形" << endl;
	}

	return 0;
}