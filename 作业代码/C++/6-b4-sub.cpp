/*2151294 信11 马威*/

#include <cstdio>   //NULL
//不再允许包含任何系统头文件

/* ----- 不允许定义任何形式的全局变量/全部数组/只读全局变量/宏定义!!!!! ----- */

/* 函数实现部分，{ }内的东西可以任意调整，目前的return只是一个示例，可改变 */
/***************************************************************************
  函数名称：tj_strlen
  功    能：求字符串str的长度
  输入参数：const char *str：待求长度的字符串（只读）
  返 回 值：int：字符串的长度
  说    明：无
***************************************************************************/
int tj_strlen(const char *str)
{
    /*1、str为空指针*/
    if (str == NULL)
        return 0;

    /*2、str不为空指针*/
    else {
        const char* p = str;
        
        /*将p停在str尾零处*/
        while (*p != '\0')
            p++;
        
        /*返回p与str之间的距离*/
        return p - str;
    }
}

/***************************************************************************
  函数名称：tj_strcat
  功    能：将字符串s2追加到s1后面，含\0
  输入参数：char *s1：待追加的字符串
            const char *s2：追加的字符串（只读）
  返 回 值：char *：新的s1
  说    明：无
***************************************************************************/
char *tj_strcat(char *s1, const char *s2)
{
    /*1、s1不为空指针、s2不为空指针*/
    if (s1 != NULL && s2 != NULL) {
        char* p = s1;

        /*将p停在s1尾零处*/
        while (*p != '\0')
            p++;

        /*追加字符，直到s2指向s2尾零为止*/
        while (*s2 != '\0') {
            *p = *s2;
            p++, s2++;
        }

        /*添加尾零*/
        *p = *s2;
        return s1;
    }

    /*2、s1不为空指针、s2为空指针*/
    else if (s1 != NULL && s2 == NULL)
        return s1;

    /*3、s1为空指针*/
    else
        return NULL;
}

/***************************************************************************
  函数名称：tj_strncat
  功    能：将字符串s2的前len个字符追加到s1后面，并添加\0
  输入参数：char *s1：待追加的字符串
            const char *s2：追加的字符来自的字符串（只读）
            const int len：追加字符个数（只读）
  返 回 值：char *：新的s1
  说    明：无
***************************************************************************/
char *tj_strncat(char *s1, const char *s2, const int len)
{
    /*1、s1不为空指针*/
    if (s1 != NULL) {

        /*若len大于或等于s2的长度，则直接调用tj_strcat()，追加整个s2*/
        if (len >= tj_strlen(s2))
            return tj_strcat(s1, s2);

        /*若len小于s2的长度*/
        else {
            char* p1 = s1;
            const char* p2 = s2;

            /*将p1停在s1尾零处*/
            while (*p1 != '\0')
                p1++;

            /*追加字符，直到p2、s2距离为len-1为止*/
            while (p2 - s2 < len - 1) {
                *p1 = *p2;
                p1++, p2++;
            }

            /*添加尾零*/
            *p1 = *p2;
            return s1;
        }
    }

    /*2、s1为空指针*/
    else
        return NULL;
}

/***************************************************************************
  函数名称：tj_strcpy
  功    能：将字符串s2复制到s1中，覆盖s1中原内容，复制时包含\0
  输入参数：char *s1：待覆盖的字符串
            const char *s2：覆盖的字符串（只读）
  返 回 值：char *：新的s1
  说    明：无
***************************************************************************/
char *tj_strcpy(char *s1, const char *s2)
{
    /*1、s1不为空指针*/
    if (s1 != NULL) {

        /*1.1、s2不为空指针*/
        if (s2 != NULL) {
            char* p = s1;

            /*覆盖字符，直到s2指向s2尾零处为止*/
            while (*s2 != '\0') {
                *p = *s2;
                p++, s2++;
            }

            /*添加尾零*/
            *p = *s2;
        }

        /*1.2、s2为空指针*/
        else
            *s1 = '\0';

        return s1;
    }

    /*2、s1为空指针*/
    else
        return NULL;
}

/***************************************************************************
  函数名称：tj_strncpy
  功    能：将字符串s2的前len个字符复制到s1中，复制时不含\0
  输入参数：char *s1：待覆盖的字符串
            const char *s2：覆盖的字符来自的字符串（只读）
            const int len：复制字符个数（只读）
  返 回 值：char *：新的s1
  说    明：无
***************************************************************************/
char *tj_strncpy(char *s1, const char *s2, const int len)
{
    /*1、s1不为空指针*/
    if (s1 != NULL) {

        /*s2不为空指针，则执行下面操作，否则跳过*/
        if (s2 != NULL) {
            char* p1 = s1;
            const char* p2 = s2;

            while (1) {

                /*覆盖字符，直到p2指向尾零、或p2、s2间距离为len时为止*/
                if (*p2 == '\0' || p2 - s2 == len)
                    break;

                *p1 = *p2;
                p1++, p2++;
            }
        }

        return s1;
    }

    /*2、s1为空指针*/
    else
        return NULL;
}

/***************************************************************************
  函数名称：tj_strcmp
  功    能：比较字符串s1和s2的大小，英文字母要区分大小写
  输入参数：const char *s1：待比较的字符串s1（只读）
            const char *s2：待比较的字符串s2（只读）
  返 回 值：int：最后一对比较的字符ASCII码差值
  说    明：无
***************************************************************************/
int tj_strcmp(const char *s1, const char *s2)
{
    /*1、s1不为空指针、s2不为空指针*/
    if (s1 != NULL && s2 != NULL) {

        /*逐个比较字符，直到有不相等的字符或其中一个指针指向尾零为止*/
        while (*s1 == *s2 && *s1 != '\0' && *s2 != '\0') {
            s1++, s2++;
        }

        return *s1 - *s2;
    }

    /*2、s1为空指针、s2不为空指针*/
    else if (s1 == NULL && s2 != NULL)
        return -1;

    /*3、s1不为空指针、s2为空指针*/
    else if (s1 != NULL && s2 == NULL)
        return 1;

    /*4、s1为空指针、s2为空指针*/
    else
        return 0;
}

/***************************************************************************
  函数名称：tj_strcasecmp
  功    能：比较字符串s1和s2的大小，英文字母不分大小写
  输入参数：const char *s1：待比较的字符串s1（只读）
            const char *s2：待比较的字符串s2（只读）
  返 回 值：int：最后一对比较的字符ASCII码差值
  说    明：1、若不相等处字符是不同的大小写字母，则统一转换为小写后比较
            2、若不相等处是大写字母和其它字符，则返回对应小写字母和其它字符的差值
***************************************************************************/
int tj_strcasecmp(const char *s1, const char *s2)
{
    int ret = 0;  /*返回值*/
    const char n = 'a' - 'A';  /*小写字母与对应大写字母ASCII码差值*/

    /*1、s1不为空指针、s2不为空指针*/
    if (s1 != NULL && s2 != NULL) {

        /*逐个比较字符，直到其中一个指针指向尾零为止*/
        while (*s1 != '\0' && *s2 != '\0') {

            if (*s1 != *s2) {

                /*若不相等处，*s1是大写字母，*s2是小写字母，则将*s1转换为小写后比较*/
                /*由于字符串只读，将*s1加上n后再比较，若仍不等，将按要求处理过的ASCII差值赋给ret后跳出*/
                if ((*s1 >= 'A' && *s1 <= 'Z') && (*s2 >= 'a' && *s2 <= 'z')) {
                    if (*s1 + n != *s2) {
                        ret = *s1 + n - *s2;
                        break;
                    }
                }

                /*若不相等处，*s2是大写字母，*s1是小写字母，则将*s2转换为小写后比较*/
                /*由于字符串只读，将*s2加上n后再比较，若仍不等，将按要求处理过的ASCII差值赋给ret后跳出*/
                else if ((*s1 >= 'a' && *s1 <= 'z') && (*s2 >= 'A' && *s2 <= 'Z')) {
                    if (*s1 - n != *s2) {
                        ret = *s1 - n - *s2;
                        break;
                    }
                }

                /*若不相等处，*s1是大写字母，*s2是其他字符，则将*s1转换为小写*/
                /*由于字符串只读，将*s1加上n，再将按要求处理过的ASCII差值赋给ret后跳出*/
                else if ((*s1 >= 'A' && *s1 <= 'Z') && (*s2 < 'a' || *s2>'z') && (*s2 < 'A' || *s2 > 'Z')) {
                    ret = *s1 + n - *s2;
                    break;
                }

                /*若不相等处，*s2是大写字母，*s1是其他字符，则将*s2转换为小写*/
                /*由于字符串只读，将*s2加上n，再将按要求处理过的ASCII差值赋给ret后跳出*/
                else if ((*s2 >= 'A' && *s2 <= 'Z') && (*s1 < 'a' || *s1>'z') && (*s1 < 'A' || *s1 > 'Z')) {
                    ret = *s1 - n - *s2;
                    break;
                }

                /*若都不符合上述特殊情况，直接将*s1、*s2的ASCII差值赋给ret后跳出*/
                else {
                    ret = *s1 - *s2;
                    break;
                }
            }

            s1++, s2++;
        }

        /*若比较结束后有指针指向尾零，返回最后一对比较的字符ASCII码差值*/
        if (*s1 == '\0' || *s2 == '\0')
            ret = *s1 - *s2;

        return ret;
    }

    /*2、s1为空指针、s2不为空指针*/
    else if (s1 == NULL && s2 != NULL)
        return -1;

    /*3、s1不为空指针、s2为空指针*/
    else if (s1 != NULL && s2 == NULL)
        return 1;

    /*4、s1为空指针、s2为空指针*/
    else
        return 0;
}

/***************************************************************************
  函数名称：tj_strncmp
  功    能：比较字符串s1和s2的前len个字符的大小，英文字母要区分大小写
  输入参数：const char *s1：待比较的字符串s1（只读）
            const char *s2：待比较的字符串s2（只读）
            const int len：比较字符的个数（只读）
  返 回 值：int：最后一对比较的字符ASCII码差值
  说    明：若len大于s1/s2中长度短的串，则比较到短串的\0即结束
***************************************************************************/
int tj_strncmp(const char *s1, const char *s2, const int len)
{
    int min, ret = 0;  /*两串长度最小值、返回值*/
    const char* p1 = s1;
    const char* p2 = s2;

    /*取两串长度最小值*/
    if (tj_strlen(s1) < tj_strlen(s2))
        min = tj_strlen(s1);
    else
        min = tj_strlen(s2);

    /*若len大于min，相当于直接整个比较s1和s2，调用函数tj_strcmp()*/
    if (len > min) 
        ret = tj_strcmp(s1, s2);

    /*若len小于等于min*/
    else {

        /*1、s1不为空指针、s2不为空指针*/
        if (s1 != NULL && s2 != NULL) {

            /*逐个比较字符，直到检查出不同字符或有指针指向尾零为止*/
            while (*p1 == *p2 && *p1 != '\0' && *p2 != '\0') {

                /*若p2、s2间距离为len-1，结束比较*/
                if (p2 - s2 == len - 1)
                    break;
                p1++, p2++;
            }

            ret = *p1 - *p2;
        }

        /*2、s1为空指针、s2不为空指针*/
        else if (s1 == NULL && s2 != NULL)
            ret = -1;

        /*3、s1不为空指针、s2为空指针*/
        else if (s1 != NULL && s2 == NULL)
            ret = 1;

        /*4、s1为空指针、s2为空指针*/
        else
            ret = 0;
    }

    return ret;
}

/***************************************************************************
  函数名称：tj_strcasencmp
  功    能：比较字符串s1和s2的前len个字符的大小，英文字母不分大小写
  输入参数：const char *s1：待比较的字符串s1（只读）
            const char *s2：待比较的字符串s2（只读）
            const int len：比较字符的个数（只读）
  返 回 值：int：最后一对比较的字符ASCII码差值
  说    明：若len大于s1/s2中长度短的串，则比较到短串的\0即结束
***************************************************************************/
int tj_strcasencmp(const char *s1, const char *s2, const int len)
{
    int min, ret = 0;  /*两串长度最小值、返回值*/
    const char* p1 = s1;
    const char* p2 = s2;
    const char n = 'a' - 'A';  /*小写字母与对应大写字母ASCII码差值*/

    /*取两串长度最小值*/
    if (tj_strlen(s1) < tj_strlen(s2))
        min = tj_strlen(s1);
    else
        min = tj_strlen(s2);

    /*若len大于min，相当于直接整个比较s1和s2，调用函数tj_strcasecmp()*/
    if (len > min)
        ret = tj_strcasecmp(s1, s2);

    /*若len小于等于min*/
    else {

        /*1、s1不为空指针、s2不为空指针*/
        if (s1 != NULL && s2 != NULL) {

            /*逐个比较字符，直到有指针指向尾零为止*/
            while (*p1 != '\0' && *p2 != '\0') {

                if (*p1 != *p2) {

                    /*若不相等处，*p1是大写字母，*p2是小写字母，则将*p1转换为小写后比较*/
                    /*由于字符串只读，将*p1加上n后再比较，若仍不等，将按要求处理过的ASCII差值赋给ret后跳出*/
                    if ((*p1 >= 'A' && *p1 <= 'Z') && (*p2 >= 'a' && *p2 <= 'z')) {
                        if (*p1 + n != *p2) {
                            ret = *p1 + n - *p2;
                            break;
                        }
                    }

                    /*若不相等处，*p2是大写字母，*p1是小写字母，则将*p2转换为小写后比较*/
                    /*由于字符串只读，将*p2加上n后再比较，若仍不等，将按要求处理过的ASCII差值赋给ret后跳出*/
                    else if ((*p1 >= 'a' && *p1 <= 'z') && (*p2 >= 'A' && *p2 <= 'Z')) {
                        if (*p1 - n != *p2) {
                            ret = *p1 - n - *p2;
                            break;
                        }
                    }

                    /*若不相等处，*p1是大写字母，*p2是其他字符，则将*p1转换为小写*/
                    /*由于字符串只读，将*p1加上n，再将按要求处理过的ASCII差值赋给ret后跳出*/
                    else if ((*p1 >= 'A' && *p1 <= 'Z') && (*p2 < 'a' || *p2 > 'z') && (*p2 < 'A' || *p2 > 'Z')) {
                        ret = *p1 + n - *p2;
                        break;
                    }

                    /*若不相等处，*p2是大写字母，*p1是其他字符，则将*p2转换为小写*/
                    /*由于字符串只读，将*p2加上n，再将按要求处理过的ASCII差值赋给ret后跳出*/
                    else if ((*p2 >= 'A' && *p2 <= 'Z') && (*p1 < 'a' || *p1 > 'z') && (*p1 < 'A' || *p1 > 'Z')) {
                        ret = *p1 - n - *p2;
                        break;
                    }

                    /*若都不符合上述特殊情况，直接将*p1、*p2的ASCII差值赋给ret后跳出*/
                    else {
                        ret = *p1 - *p2;
                        break;
                    }
                }

                /*若直到两个字符串的尾零同时比较前还没比出大小，则两字符串相等，将0赋给ret后跳出*/
                else if (*p1 == '\0' && *p2 == '\0') {
                    ret = 0;
                    break;
                }

                /*若直到两个字符串标定范围内，最后一对字符同时比较时还没比出大小，则两字符串相等，将0赋给ret后跳出*/
                if ((*p1 == *p2 || *p1 + n == *p2 || *p1 == *p2 + n) && p2 - s2 == len - 1) {
                    ret = 0;
                    break;
                }

                p1++, p2++;
            }
        }

        /*2、s1为空指针、s2不为空指针*/
        else if (s1 == NULL && s2 != NULL)
            ret = -1;

        /*3、s1不为空指针、s2为空指针*/
        else if (s1 != NULL && s2 == NULL)
            ret = 1;

        /*4、s1为空指针、s2为空指针*/
        else
            ret = 0;
    }

    return ret;
}

/***************************************************************************
  函数名称：tj_strupr
  功    能：将字符串str中所有小写字母均转为大写，其他字符不变，转换后放在原串中
  输入参数：char *str：待转换的字符串
  返 回 值：char *：转换后的串
  说    明：无
***************************************************************************/
char *tj_strupr(char *str)
{
    /*若str不为空指针，执行下列操作*/
    if (str != NULL) {
        char* p = str;

        /*逐个检查字符，直到指针指向尾零为止*/
        while (*p != '\0') {

            /*若检查出小写字母，则转换成大写*/
            if (*p >= 'a' && *p <= 'z')
                *p = *p - 'a' + 'A';

            p++;
        }
    }

    return str;
}

/***************************************************************************
  函数名称：tj_strlwr
  功    能：将字符串str中所有大写字母均转为小写，其他字符不变，转换后放在原串中
  输入参数：char *str：待转换的字符串
  返 回 值：char *：转换后的串
  说    明：无
***************************************************************************/
char *tj_strlwr(char *str)
{
    /*若str不为空指针，执行下列操作*/
    if (str != NULL) {
        char* p = str;

        /*逐个检查字符，直到指针指向尾零为止*/
        while (*p != '\0') {

            /*若检查出大写字母，则转换成小写*/
            if (*p >= 'A' && *p <= 'Z')
                *p = *p + 'a' - 'A';

            p++;
        }
    }

    return str;
}

/***************************************************************************
  函数名称：tj_strchr
  功    能：在字符串str中寻找字符ch第1次出现的位置，顺序是从左到右
  输入参数：const char *str：待检查的字符串（只读）
            const char ch：目标字符（只读）
  返 回 值：int：ch在str中第一次出现的位置（从左到右）
  说    明：若未找到，则返回零
***************************************************************************/
int tj_strchr(const char *str, const char ch)
{
    /*1、str不为空指针*/
    if (str != NULL) {
        const char* p = str;

        /*逐个检查字符，直到检查出目标字符或指针指向尾零为止*/
        while (*p != ch && *p != '\0')
            p++;

        /*若*p不为尾零，则已经找到目标字符，返回p、str间的距离+1*/
        if (*p)
            return p - str + 1;

        /*若*p为尾零，则未找到，返回0*/
        else
            return 0;
    }

    /*2、str为空指针*/
    else
        return NULL;
}

/***************************************************************************
  函数名称：tj_strstr
  功    能：在字符串str中寻找字符串substr第1次出现的位置，顺序是从左到右
  输入参数：const char *str：待检查的字符串（只读）
            const char *substr：待寻找的字符串（只读）
  返 回 值：int：字符串str中字符串substr第1次出现的位置（从左到右）
  说    明：若未找到，则返回零
***************************************************************************/
int tj_strstr(const char *str, const char *substr)
{
    const char* p1 = str;
    const char* p2 = substr;
    int ret = 0;  /*返回值*/

    /*1、str不为空指针、substr不为空指针*/
    if (str != NULL && substr != NULL) {

        /*逐个检查字符，直到p1指向str尾零为止*/
        while (*p1 != '\0') {

            /*若跟substr首字母相同，则进入下一步检查*/
            if (*p1 == *substr) {
                const char* p = p1;  /*再定义一个指针变量p，从p1位置出发*/
                p2 = substr;         /*复位p2到substr首地址*/

                /*逐个检查字符，直到p2指向substr尾零为止*/
                while (*p2 != '\0') {

                    /*若检查出不同字符，则结束该步检查*/
                    if (*p != *p2)
                        break;

                    p++, p2++;
                }

                /*若p2指向substr尾零，则已找到，返回p1、str间的距离+1*/
                if (*p2 == '\0') {
                    ret = p1 - str + 1;
                    break;
                }

            }

            p1++;
        }
    }

    /*2、str、substr中至少有一个为空指针*/
    else
        ret = 0;

    return ret;
}

/***************************************************************************
  函数名称：tj_strrchr
  功    能：在字符串str中寻找字符ch第1次出现的位置，顺序是从右到左
  输入参数：const char *str：待检查的字符串（只读）
            const char ch：目标字符（只读）
  返 回 值：int：ch在str中第一次出现的位置（从右到左）
  说    明：若未找到，则返回零
***************************************************************************/
int tj_strrchr(const char *str, const char ch)
{
    /*1、str不为空指针*/
    if (str != NULL) {
        const char* p = str;

        /*将p停在str尾零处*/
        while (*p != '\0')
            p++;

        /*逐个检查字符，直到p指向str首地址为止*/
        while (*p != ch && p > str)
            p--;

        /*若停止时*p为目标字符，则已找到，返回p、str间距离+1*/
        if (*p == ch)
            return p - str + 1;

        /*若停止时*p不为目标字符，则未找到，返回0*/
        else
            return 0;
    }

    /*2、str为空指针*/
    else
        return NULL;
}

/***************************************************************************
  函数名称：tj_strrstr
  功    能：在字符串str中寻找字符串substr第1次出现的位置，顺序是从右到左
  输入参数：const char *str：待检查的字符串（只读）
            const char *substr：待寻找的字符串（只读）
  返 回 值：int：字符串str中字符串substr第1次出现的位置（从右到左）
  说    明：若未找到，则返回零
***************************************************************************/
int tj_strrstr(const char *str, const char *substr)
{
    int ret = 0;  /*返回值*/
    const char* p1 = str;
    const char* p2 = substr, * end_substr = substr;

    /*1、str不为空指针、substr不为空指针*/
    if (str != NULL && substr != NULL) {

        /*将end_substr停在substr尾零前最后一个字符处*/
        while (*end_substr != '\0')
            end_substr++;
        end_substr--;

        /*将p1停在str尾零前最后一个字符处*/
        while (*p1 != '\0')
            p1++;
        p1--;

        /*逐个检查字符*/
        while (1) {

            /*若跟substr首字母相同，则进入下一步检查*/
            if (*p1 == *end_substr) {
                const char* p = p1;  /*再定义一个指针变量p，从p1位置出发*/
                p2 = end_substr;     /*复位p2到end_substr的位置*/

                while (1) {

                    /*若检查出不同字符，则结束该步检查*/
                    if (*p != *p2)
                        break;

                    /*若p2未到达substr首地址，p、p2继续回退，否则结束该步检查，防止数组越界*/
                    if (p2 > substr)
                        p--, p2--;
                    else
                        break;
                }

                /*该步检查结束时若*p等于*p2，则已找到，返回p1、str间的距离-substr的长度+2*/
                if (*p == *p2) {
                    ret = p1 - tj_strlen(substr) + 1 - str + 1;
                    break;
                }
            }

            /*若p1未到达str首地址，p1继续回退，否则结束检查，防止数组越界*/
            if (p1 > str)
                p1--;
            else
                break;
        }
    }

    /*2、str、substr中至少有一个为空指针*/
    else
        ret = 0;

    return ret;
}

/***************************************************************************
  函数名称：tj_strrev
  功    能：字符串反转，放入原串中
  输入参数：char *str：待反转处理的字符串
  返 回 值：char *：反转后的串
  说    明：无
***************************************************************************/
char *tj_strrev(char *str)
{
    /*1、str不为空指针*/
    if (str != NULL) {
        char* p1 = str;
        char* p2 = str;
        char t;  /*中间变量*/

        /*将p2停在str尾零处*/
        while (*p2 != '\0')
            p2++;

        /*若str首地址不为尾零，则str非空，p2回退至尾零前最后一个字符处，防止数组越界*/
        if (*str)
            p2--;

        /*逐个反转字符*/
        while (1) {
            t = *p1;
            *p1 = *p2;
            *p2 = t;

            /*str长度为奇数，则p1、p2指向同一处时结束；str长度为偶数，则p1、p2间的距离为1时结束*/
            if (p1 == p2 || p2 - p1 == 1)
                break;

            p1++, p2--;  /*p1前进、p2回退*/
        }

        return str;
    }

    /*2、str为空指针*/
    else
        return NULL;
}
